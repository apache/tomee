<?xml version="1.0" encoding="UTF-8"?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
-->

<!--
    This ANT build file is used to run the JPA 2.0 TCK. It assumes that you have
    the TCK, config  and patches zip files located at:

        ${user.home}/.m2/privaterepos/jpatck-2.0_15-Aug-2011.zip
        ${user.home}/.m2/privaterepos/jpatck-2.0_15-Aug-2011_config.zip (may not exist)

    If you have that file in a different location, it can be specified with
    the "tck.zip" and "tck_patches.zip" system property.

    The TCK running process will do the following:
        1. Find the TCK zip file and extract it
        2. Create an openjpa-provider.properties file with the OpenJPA config
        3. Modify the TCK's main configuration file (ts.jte) to use OpenJPA
        4. Run the database initialization script
        5. Run the TCK script
        6. Parse the TCK result log to determine to fail the build or not

    Other options are documented in the Maven pom.xml which calls this script.
-->
<!--
    Please keep the project tag on one line to avoid confusing
    the release plugin.
-->
<project name="JPA2TCK" default="run-tck">

    <!-- Import antlib/ant-contrib for If/then/else/for support -->
    <taskdef resource="net/sf/antcontrib/antlib.xml"/>

    <!--
        Target:  init
        Description:  This initializes required properties and validates that
                      required TCK zip files are present on the system and
                      then extracts them.
     -->
    <target name="init">
        <property name="tck.level" value="jpatck-2.0_15-Aug-2011" />
        <property name="tck.zip" value="${LOCAL_M2_REPO}/../privaterepos/${tck.level}.zip" />
        <available property="tck.available" file="${tck.zip}" />
        <fail unless="tck.available">The TCK file specified in the "tck.zip" system property (${tck.zip}) does not exist. This file must be downloaded separately in order to be able to run the JPA 2.0 TCK</fail>
<!--
        <property name="tck_config.zip" value="${LOCAL_M2_REPO}/../privaterepos/${tck.level}_config.zip" />
        <available property="tck_config.available" file="${tck_config.zip}" />
        <fail unless="tck_config.available">The TCK config file specified in the "tck_config.zip" system property (${tck_config.zip}) does not exist. This file must be downloaded separately in order to be able to run the JPA 2.0 TCK</fail>

        <property name="tck_patches.zip" value="${LOCAL_M2_REPO}/../privaterepos/${tck.level}_patches.zip" />
        <available property="tck_patches.available" file="${tck_patches.zip}" />
        <fail unless="tck_patches.available">The TCK patches file specified in the "tck_patches.zip" system property (${tck_patches.zip}) does not exist. This file must be downloaded separately in order to be able to run the JPA 2.0 TCK</fail>
-->

        <delete dir="${tck.dir}" />
        <unzip overwrite="false" src="${tck.zip}" dest="${tck.base}" />
<!--
        <unzip overwrite="true" src="${tck_config.zip}" dest="${tck.base}" />
        <unzip overwrite="true" src="${tck_patches.zip}" dest="${tck.base}" />
-->
        <copy overwrite="true"
            file="${tck.dir}/bin/ts.jte" tofile="${tck.dir}/bin/ts.jte.orig" />
        <copy overwrite="true"
            file="${tck.dir}/bin/ts.jtx" tofile="${tck.dir}/bin/ts.jtx.orig" />
        <!-- Pluggability tests using Toplink needs this dir created -->
        <mkdir dir="${tck.dir}/domains/domain1/logs" />
        <!-- create other missing directory -->
        <mkdir dir="${tck.dir}/weblib" />
    </target>


    <!--
        Target:  setup
        Description:  This updates the TCK configuration for OpenJPA.
     -->
    <target name="setup">
        <property name="db.name" value="${tck.db.name}" />
        <property name="db.driver" value="${connection.driver.name}" />
        <property name="db.url" value="${connection.url}" />
        <property name="db.username" value="${connection.username}" />
        <property name="db.password" value="${connection.password}" />

        <property name="openjpa.Log" value="DefaultLevel=TRACE" />

        <property name="jpatck.test" value="" />

        <property name="tck.reports" value="${tck.base}/reports" />
        <property name="tck.work" value="${tck.base}/work" />

        <property name="openjpa.properties" value="${tck.dir}/openjpa-provider.properties" />
        <property name="toplink.properties" value="${tck.dir}/bin/toplink-provider.properties" />
        <!-- create the OpenJPA properties for the TCK run -->
        <echo append="false" file="${openjpa.properties}">
javax.persistence.provider: org.apache.openjpa.persistence.PersistenceProviderImpl
openjpa.ConnectionDriverName: ${db.driver}
openjpa.ConnectionURL: ${db.url}
openjpa.ConnectionUserName: ${db.username}
openjpa.ConnectionPassword: ${db.password}
openjpa.FetchBatchSize: -1
openjpa.Compatibility: StrictIdentityValues=true
openjpa.Sequence: time
openjpa.Log: ${openjpa.Log}
openjpa.jdbc.DBDictionary: (StoreCharsAsNumbers=true,NumericTypeName="DECIMAL(18,2)")
openjpa.jdbc.SchemaFactory: native(ForeignKeys=true)
openjpa.jdbc.SynchronizeMappings: buildSchema(ForeignKeys=true)
openjpa.ConnectionFactoryProperties: PrintParameters=True
        </echo>

        <path id="javart">
            <fileset dir="${java.home}/lib">
              <include name="**/*.jar" />
            </fileset>
        </path>
        <pathconvert property="javart.property" refid="javart" />

        <!-- Append OpenJPA-specific configuration -->
        <property name="jpatck.config" value="${tck.dir}/bin/ts.jte" />

        <echo append="false" file="${jpatck.config}.tmp">


#########################################################################
## OpenJPA specific properties follow
#########################################################################

jpa.home=${tck.dir}
work.dir=${tck.work}
report.dir=${tck.reports}
jpa.classes=${cp.property}
# jpa.classes includes Derby, so only set database.classes for other DBs
database.classes=
# different properties needed for pluggability bucket
openjpa.properties=${openjpa.properties}
toplink.properties=${toplink.properties}
# Need to specify java.* classes, both in Windows/UNIX locations as well as Mac.
# This includes a few different possible locations; only one of them needs to
# actually work for a given environment.
sigTestClasspath=${javart.property}${path.separator}${cp.property}
persistence.unit.properties.file.full.path=${provider.properties}
javax.persistence.jdbc.driver: ${db.driver}
javax.persistence.jdbc.url: ${db.url}
javax.persistence.jdbc.user: ${db.username}
javax.persistence.jdbc.password: ${db.password}
database.driver=${db.driver}
database.url=${db.url}
database.user=${db.username}
database.passwd=${db.password}
databaseName=${db.name}
jdbc.lib.classpath=${cp.test.classpath}
# disable initdb.xml table creation
create.cmp.tables=false

        </echo>

        <!-- convert backslashes and known paths with spaces
            to get around a problem with the TCK testrunner
            on windows -->
        <echo>Update directory paths if running on Windows</echo>
        <replace summary="yes" file="${jpatck.config}.tmp" replacefilterfile="windows-replacefilter.properties" />

        <!-- append our updated config properties to a clean ts.jte -->
        <copy overwrite="true"
            file="${tck.dir}/bin/ts.jte.orig" tofile="${tck.dir}/bin/ts.jte" />
        <concat append="true" destfile="${jpatck.config}">
            <fileset file="${jpatck.config}.tmp" />
        </concat>

        <path id="agent.path">
            <fileset dir="../../openjpa/target">
                <include name="*.jar" />
                <exclude name="*-sources.jar" />
                <exclude name="*-shaded.jar" />
                <exclude name="original-*.jar" />
                <exclude name="*-tests.jar" />
                <exclude name="*-javadoc.jar" />
            </fileset>
        </path>
        <pathconvert dirsep="/" property="agent" refid="agent.path" />
        <property name="agent.properties" value="" />
        <echo>AGENT: ${agent}${agent.properties}</echo>

        <!-- Use the following values to start Eclipse remote debug
    	<property name="DEBUG" value="-Djava.compiler=NONE -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=7777" />
        -->    	
    	<property name="DEBUG" value="" />
        <!--
            Add in a javaagent argument (optional in JPA2 TCK.)
            Also, we need to specify the default MetaDataFactory
            inorder to allow tests that don't have any
            persistent classes to work (like the SignatureTest)
        -->
        <replace file="${jpatck.config}">
            <replacefilter token="-Ddeliverable.class=${deliverable.class}" value="-Ddeliverable.class=${deliverable.class} -javaagent:${agent}${agent.properties} ${DEBUG} -Dopenjpa.MetaDataFactory=jpa(DefaultAccessType=PROPERTY)"/>
        </replace>

        <!-- Fix path for java.security.policy -->
        <replace file="${jpatck.config}">
            <replacefilter token="-Djava.security.policy=${bin.dir}/harness.policy" value="-Djava.security.policy=${ts.home}/bin/harness.policy"/>
        </replace>

        <!-- cleanup reports/work dirs from any prior runs -->
        <delete dir="${tck.reports}" />
        <delete dir="${tck.work}" />
        <echo>Logging JPA 2.0 TCK output to ${tck.log}</echo>
    </target>


    <!--
        Macro for the TCK harness launcher
    -->
    <macrodef name="tsant">
        <attribute name="dir" default="${tck.dir}/src" />
        <attribute name="buildfile" />
        <attribute name="target" />
        <attribute name="tmo" default="7200000" />
        <sequential>
            <java classname="org.apache.tools.ant.launch.Launcher" fork="true" failonerror="false" dir="@{dir}" append="true" output="${tck.log}" timeout="@{tmo}" resultproperty="tsant.result">
                <arg value="-emacs" />
                <arg value="-buildfile" />
                <arg value="@{buildfile}" />
                <arg value="-listener" />
                <arg value="com.sun.ant.TSBuildListener" />
                <arg value="-logger" />
                <arg value="com.sun.ant.TSLogger" />
                <arg value="@{target}" />

                <env key="TS_HOME" value="${tck.dir}" />
                <sysproperty key="ts.home" value="${tck.dir}" />

                <env key="ANT_HOME" value="${tck.dir}/tools/ant" />
                <sysproperty key="ant.home" value="${tck.dir}/tools/ant" />

                <!--
                <sysproperty key="pkg.dir" value="${jpatck.pkg.dir}" />
                <sysproperty key="test" value="${jpatck.test}" />
                -->

                <classpath>
                    <path refid="cp" />
                    <fileset dir="${tck.dir}/tools/ant/lib">
                        <include name="**/*.jar" />
                    </fileset>
                    <fileset dir="${tck.dir}/lib">
                        <include name="**/*.jar" />
                    </fileset>
                </classpath>
            </java>
        </sequential>
    </macrodef>


    <!--
        Macro to determine how many tests passed/failed
    -->
    <macrodef name="results.count">
        <!-- Figure out the Passed/Failed counts -->
        <sequential>
        <resourcecount property="count.passed">
            <tokens>
                <concat>
                    <filterchain>
                        <tokenfilter>
                            <containsstring contains="Passed."/>
                        </tokenfilter>
                    </filterchain>
                    <fileset dir="${tck.reports}" includes="summary.txt" />
                </concat>
            </tokens>
        </resourcecount>
        <resourcecount property="count.failed">
            <tokens>
                <concat>
                    <filterchain>
                        <tokenfilter>
                            <containsstring contains="Failed."/>
                        </tokenfilter>
                    </filterchain>
                    <fileset dir="${tck.reports}" includes="summary.txt" />
                </concat>
            </tokens>
        </resourcecount>
        <echo>TCK Results - Passed: ${count.passed}, Failed: ${count.failed}</echo>
        </sequential>
    </macrodef>


    <!--
        Target:  run-tck
        Description:  This is the main routine that runs the TCK, after
                      all other setup steps have been performed.
        Input: jpatck.pkg.dir System property defines a commna-spearated list of test cases to be run.
               If not set or set to empty string, all tck tests will be exercised.
        Note: Beaware if jpatck.pkg.dir includes pluggability test in the dir hierarchy, the pluggability
              test will fail (5 failures) due to [enable|disable].ts.persistence.provider targets are
              not invoked, which is required for the pluggability tests.
     -->
    <target name="run-tck">
        <echo>Running JPA 2.0 TCK tests</echo>
        <echo>Init must have been called before running this target!</echo>
        <property name="tck.log" value="${tck.base}/openjpa-tck.log" />
        <property name="provider.properties" value="${openjpa.properties}" />

        <!-- call TCK setup with above run specific properties set -->
        <fail unless="OPENJPA_CLASSPATH">The OPENJPA_CLASSPATH was not provided and needs to point to the required OpenJPA and Derby runtime jars.</fail>
        <antcall target="setup">
            <param name="cp.property" value="${OPENJPA_CLASSPATH}" />
        </antcall>

        <!-- backup our updated ts.jte for later debugging -->
        <copy overwrite="true"
            file="${tck.dir}/bin/ts.jte" tofile="${tck.base}/ts.jte.tck" />

        <!-- HACK - rebuild jpatck/dist jars for persistence.xml fixes -->
        <echo>Calling TCK build.all</echo>
        <tsant buildfile="${tck.dir}/bin/build.xml" target="build.all" />
        <echo>TCK build.all returned result=${tsant.result}</echo>

        <!-- first initialize the database -->
        <echo>Calling TCK initdb.xml</echo>
        <tsant dir="${tck.dir}/bin" buildfile="${tck.dir}/bin/initdb.xml" target="init.database" />
        <echo>TCK initdb.xml returned result=${tsant.result}</echo>

        <!-- Database table set up -->
        <!-- OpenJPA relies on SynchronizeMappings to create the database tables...
             ... except in a couple of cases where we will pre-create the tables.   -->
        <echo>Calling OpenJPA create.openjpa.sql.xml</echo>
        <ant antfile="${basedir}/sql/create.openjpa.sql.xml" inheritRefs="true" />

        <!-- We are attempting to change TCK build.xml;s incorrect property name
             for the pluggability test enablement...  -->
        <replace file="${tck.dir}/bin/build.xml">
            <replacefilter token="persistence.properties.file"
            	           value="persistence.unit.properties.file.full.path"/>
        </replace>
        <replace file="${tck.dir}/bin/build.xml">
        	<replacetoken><![CDATA[<replaceregexp file="${bin.dir}/ts.jte"]]></replacetoken>
            <replacevalue><![CDATA[<replaceregexp flags="g" file="${bin.dir}/ts.jte"]]></replacevalue>
        </replace>

        <property name="jpatck.run.tmo" value="7200000" />
        <!-- now run the TCK -->
        <if>
            <and>
                <isset property="jpatck.pkg.dir" />
                <not>
                    <length string="${jpatck.pkg.dir}" trim="true" length="0" />
                </not>
            </and>
        <then>
            <for list="${jpatck.pkg.dir}" param="for.test" trim="true">
                <sequential>
                    <if>
                        <contains string="@{for.test}" substring="pluggability"/>
                    <then>
                        <echo>Calling enable.ts.persistence.provider for pluggability test.</echo>
                        <tsant buildfile="${tck.dir}/bin/build.xml" target="enable.ts.persistence.provider" />
                    </then>
                    </if>

                    <echo>Calling TCK build.xml for pkg.dir=@{for.test}</echo>
                    <property name="dir" value="${tck.dir}/src/@{for.test}" />
                    <tsant dir="${dir}" buildfile="${dir}/build.xml" target="runclient" tmo="${jpatck.run.tmo}" />

                    <if>
                        <contains string="@{for.test}" substring="pluggability"/>
                    <then>
                        <echo>Calling disable.ts.persistence.provider for pluggability test.</echo>
                        <tsant buildfile="${tck.dir}/bin/build.xml" target="disable.ts.persistence.provider" />
                    </then>
                    </if>
                </sequential>
            </for>
        </then>
        <else>
            <echo>Calling TCK build.xml for ALL tests</echo>
            <property name="dir.all" value="${tck.dir}/bin" />
            <tsant dir="${dir.all}" buildfile="${dir.all}/build.xml" target="run.all" tmo="${jpatck.run.tmo}"/>
        </else>
        </if>

        <echo>TCK build.xml returned result=${tsant.result}</echo>

        <!-- archive the results and check for test failures -->
        <antcall target="zip-artifacts">
            <param name="results.name" value="tck" />
        </antcall>
    </target>


    <!--
        Target:  zip-artifacts
        Description:  Collects generic TCK test artifacts for debugging
     -->
    <target name="zip-artifacts">
        <echo>Gathering test artifacts for Sun JPA 2.0 TCK</echo>
        <copy overwrite="true"
            file="${tck.reports}/summary.txt"
            tofile="${tck.base}/summary-${results.name}.txt" />
        <property name="tck.results.archive" value="${tck.base}/openjpa-${results.name}-results.zip" />
        <!-- archive the results -->
        <zip destfile="${tck.results.archive}">
            <fileset dir="${tck.work}" />
            <fileset dir="${tck.reports}" />
            <fileset dir="${tck.base}">
                <include name="*${results.name}.log" />
                <include name="*${results.name}.txt" />
                <include name="ts.jte.${results.name}" />
            </fileset>
        </zip>
        <echo>Results archive at: ${tck.results.archive}</echo>

        <!--
            The TCK's Java process doesn't actually fail when
            tests fail, so we need to parse the results file
            for a string indicating whether or not it passed.
        -->
        <results.count />
        <loadfile property="jpatck.results" srcfile="${tck.work}/jtData/log.txt" />
        <condition property="jpatck.failed">
            <contains string="${jpatck.results}" substring="Completed test run: not ok" />
        </condition>
        <fail if="jpatck.failed">Test Results (${results.name}):  FAILED ${count.failed} tests!</fail>
        <!-- else -->
        <echo>Test Results (${results.name}):  PASSED!</echo>
    </target>

</project>
