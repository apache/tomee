#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Format for the different levels follows this spirit:
#
# 1. Should be short and fixed such that someone could search/grep for it
#    without having to know/use regular expressions.  These tend to be similar
#    to the message key.
#
# 2. Intended to contain the issue expressed in 1 with only the essential
#    details, should not line wrap if possible.  Be terse.
#
# 3. Teacher's assistant.  A much more conversational and possibly more detailed
#    explanation of the issue, should tell the user what to do to fix the problem.
#    I.e. don't just point out what is wrong, also point out what is right.  Use
#    several lines if needed.
#


# 0 - Error Message
# 1 - Stack Trace
1.cannot.validate        \u091c\u093e\u0930 \u0915\u094b \u092e\u093e\u0928\u094d\u092f \u0928\u0939\u0940\u0902 \u0915\u0930 \u0938\u0915\u0924\u0947
2.cannot.validate        \u091c\u093e\u0930 \u0915\u094b \u092e\u093e\u0928\u094d\u092f \u0928\u0939\u0940\u0902 \u0915\u0930 \u0938\u0915\u0924\u0947: {0}
3.cannot.validate        \u091c\u093e\u0930 \u0915\u094b \u092e\u093e\u0928\u094d\u092f \u0928\u0939\u0940\u0902 \u0915\u0930 \u0938\u0915\u0924\u0947: {0}

# 0 - Class name
# 1 - Element (home, ejb-class, remote)
# 2 - Bean name
1.missing.class           \u0932\u093e\u092a\u0924\u093e \u0915\u094d\u0932\u093e\u0938
2.missing.class           \u0932\u093e\u092a\u0924\u093e \u0915\u094d\u0932\u093e\u0938 <{1}> {0}
3.missing.class           \u0915\u094d\u0932\u093e\u0938 {0} \u0928\u0939\u0940\u0902 \u092e\u093f\u0932\u0940 . \u091c\u093e\u0902\u091a \u0915\u0930\u0947\u0902 \u0915\u0940 \u092c\u0940\u0928 {2} \u0915\u0947 {1} \u090f\u0932\u0947\u092e\u0947\u0928\u094d\u091f \u092e\u0947\u0902 \u0928\u093f\u0930\u094d\u0926\u093f\u0937\u094d\u091f \u0915\u094d\u0932\u093e\u0938 \u0915\u0940 \u0935\u0930\u094d\u0924\u0928\u0940 \u0920\u0940\u0915 \u0939\u0948 \u0914\u0930 \u0915\u094d\u0932\u093e\u0938 \u091c\u0930 \u092e\u0947\u0902 \u092e\u094c\u091c\u0942\u0926 \u0939\u0948 

# 0 - Class name
# 1 - EJB Class name
1.wrong.class.type        \u0917\u0932\u0924 \u092a\u094d\u0930\u0915\u093e\u0930 \u0915\u0940 \u0915\u094d\u0932\u093e\u0938
2.wrong.class.type        \u0917\u0932\u0924 \u092a\u094d\u0930\u0915\u093e\u0930 \u0915\u0940 \u0915\u094d\u0932\u093e\u0938 {0}
3.wrong.class.type        \u0915\u094d\u0932\u093e\u0938 {0 } \u0917\u0932\u0924 \u092a\u094d\u0930\u0915\u093e\u0930 \u0915\u0940 \u0939\u0948, \u092f\u0939 {1 } \u0915\u094b \u090f\u0915\u094d\u0938\u091f\u0947\u0902\u0921 \u0928\u0939\u0940\u0902 \u0915\u0930\u0924\u0940
# 0 - method name
# 1 - full method
# 2 - remote|home
# 3 - interface name
# 4 - EJB Class name
1.no.busines.method       \u0910\u0938\u093e \u0915\u094b\u0908 \u092c\u093f\u091c\u093c\u0928\u0938 \u092e\u0947\u0925\u0921 \u0928\u0939\u0940\u0902
2.no.busines.method       \u092c\u093f\u091c\u093c\u0928\u0938 \u092e\u0947\u0925\u0921 {0 } \u0907\u092e\u094d\u092a\u094d\u0932\u0947\u092e\u0947\u0902\u091f \u0928\u0939\u0940\u0902 \u0915\u093f\u092f\u093e \u0917\u092f\u093e .
3.no.busines.method       \u092c\u093f\u091c\u093c\u0928\u0938 \u092e\u0947\u0925\u0921 {1 } \u0907\u092e\u094d\u092a\u094d\u0932\u0947\u092e\u0947\u0902\u091f(\u0932\u093e\u0917\u0942) \u0928\u0939\u0940\u0902 \u0915\u093f\u092f\u093e \u0917\u092f\u093e . \u092f\u0939 \u092e\u0947\u0925\u0921 {2 } \u0907\u0902\u091f\u0930\u092b\u0947\u0938 {3 } \u092e\u0947\u0902 \u0918\u094b\u0937\u093f\u0924 \u0915\u093f\u092f\u093e \u0917\u092f\u093e \u0925\u093e \u0932\u0947\u0915\u093f\u0928 \u0908.\u091c.\u092c\u0940 \u0915\u094d\u0932\u093e\u0938 \u092e\u0947\u0902 \u0907\u092e\u094d\u092a\u094d\u0932\u0947\u092e\u0947\u0902\u091f(\u0932\u093e\u0917\u0942) \u0928\u0939\u0940\u0902 \u0915\u093f\u092f\u093e \u0917\u092f\u093e 

# fail(b, "no.busines.method.args", interfaceMethods[i].getName(), interfaceMethods[i].toString(), "local", intrface.getName(), beanClass.getName(), differentArgs.size());
1.no.busines.method.args       \u0910\u0938\u093e \u0915\u094b\u0908 \u092c\u093f\u091c\u093c\u0928\u0938 \u092e\u0947\u0925\u0921  \u0928\u0939\u0940\u0902 \u0939\u0948. \u0917\u0932\u0924 \u0906\u0930\u094d\u0917\u0941\u092e\u0947\u0902\u091f\u094d\u0938 \u0907\u0938\u094d\u0924\u0947\u092e\u093e\u0932 \u0915\u093f\u092f\u0947 \u0939\u0948 .
2.no.busines.method.args       \u092c\u093f\u091c\u093c\u0928\u0938 \u092e\u0947\u0925\u0921 {0 } \u0915\u0947 \u0906\u0930\u094d\u0917\u0941\u092e\u0947\u0902\u091f\u094d\u0938 \u092e\u0948\u091a \u0928\u0939\u0940\u0902 \u0915\u0930\u0924\u0947 .
3.no.busines.method.args       Business method {1} not implemented. The method was declared in the {2} interface {3}, but not implemented in the ejb class {4}.  There are {5} method that have the same name but different arguments.

# fail(b, "no.busines.method.case", interfaceMethods[i].getName(), interfaceMethods[i].toString(), "local", intrface.getName(), beanClass.getName(), differentCase.size());
1.no.busines.method.case       No such business method.  Possible case-sensitive mismatch.
2.no.busines.method.case       Business method {0} not implemented.  Possible case-sensitive mismatch.
3.no.busines.method.case       Business method {1} not implemented. The method was declared in the {2} interface {3}, but not implemented in the ejb class {4}.  There are {5} method that have the same name but using a different case.

# 0 - home interface
# 1 - remote interface
1.no.home.create          No create method.
2.no.home.create          No create method in {0}.
3.no.home.create          The home interface {0} must declare at least one create method. Example:\n\n\tpublic {1} create() throws javax.ejb.CreateException, java.rmi.RemoteException;

# 1 - EJB Class name
# 2 - create name
# 3 - create params
1.session.no.ejb.create     Create method not implemented.
2.session.no.ejb.create     Create method not implemented: {1}({2}).
3.session.no.ejb.create     There should be a create method in the bean class {0} with the following signature:\n\n\tpublic void {1}({2}) throws javax.ejb.CreateException

# 1 - EJB Class name
# 2 - create name
# 3 - primary key class
# 4 - create params
1.entity.no.ejb.create    Create method not implemented.
2.entity.no.ejb.create    Create method not implemented: {2}({3}).
3.entity.no.ejb.create    There should be a create method in the bean class {0} with the following signature:\n\n\tpublic {1} {2}({3}) throws javax.ejb.CreateException

#This is being used in a method which is not called by any other method -- commenting out for now
# 1 - EJB Class name
# 2 - create name
# 3 - create params
#1.no.ejb.post.create      No ejbPostCreate method
#2.no.ejb.post.create      Missing create method: {1}({2})
#3.no.ejb.post.create      Entity create method with no matching ejbPostCreate.  There should be an ejbPostCreate method in the bean class {0} with the following signature:\n\n\tpublic void {1}({2}) throws javax.ejb.CreateException

# warn(b, "unused.ejb.create", b.getEjbClass(), ejbCreate.getName(), paramString, create.toString());
1.unused.ejb.create       Unused ejbCreate method
2.unused.ejb.create       Unused ejbCreate method: {1}({2})
3.unused.ejb.create       Create method will never be called.  The bean class {0} defines the create method {1}({2}), but there is no matching {3}({2}) method in the home or local-home interfaces.

# warn(b, "unused.ejbPostCreate", b.getEjbClass(), postCreate.getName(), paramString, ejbCreate.toString());
1.unused.ejbPostCreate       Unused ejbPostCreate method
2.unused.ejbPostCreate       Unused ejbPostCreate method: {1}({2})
3.unused.ejbPostCreate       PostCreate method will never be called.  The bean class {0} defines the create method {1}({2}), but there is no matching {3}({2}) method defined in the bean class.


# 0 - Class name
# 1 - Element (home, ejb-class, remote)
# 2 - Bean name
# 3 - Dependent Class name
1.misslocated.class           Misslocated class
2.misslocated.class           Misslocated class {0}
3.misslocated.class           The class {0} was found in a parent classloader and was loaded from there rather than this jar.  However, a dependent class {3} was not found in the parent classloader.  \n\nThere are two ways to fix this:\n\nOne, remove the class {0} from the jar in the parent classloader to ensure the class is only loaded from this jar.\n\nTwo, move the dependent class {3} and any other dependent classes into the jar in the parent classloader.

# 0 - Referring Class name
# 1 - Dependent Class name
# 2 - Element (home, ejb-class, remote)
# 3 - Bean name
# fail(b, "missing.dependent.class", className, missingClass, type, b.getEjbName());
1.missing.dependent.class           Missing dependent class or library
2.missing.dependent.class           Missing dependent class or library: {1} needed by {0}
3.missing.dependent.class           The class {1} not found and is referenced by the <{2}> class {0}.  The Check that the class or related library is available in the classpath


# CheckAssemblyBindings.java
# fail("InterceptorBinding", "interceptorBinding.noSuchEjbName", binding.getEjbName(), join(interceptorClasses, ","));
1.interceptorBinding.noSuchEjbName = Referenced EJB does not exist
2.interceptorBinding.noSuchEjbName = Referenced EJB does not exist: {0}
3.interceptorBinding.noSuchEjbName = Binding refers to an EJB, {0}, that does not exist.  Interceptors listed in binding: {1}

# fail("InterceptorBinding", "interceptorBinding.ejbNameRequiredWithMethod", binding.getMethod().getMethodName(), join(interceptorClasses, ","));
1.interceptorBinding.ejbNameRequiredWithMethod = ejb-name required with method binding
2.interceptorBinding.ejbNameRequiredWithMethod = ejb-name required with binding on method "{0}".
3.interceptorBinding.ejbNameRequiredWithMethod = Binding an interceptor to a specific method requires the ejb-name of the bean to also be specified.  Fix binding on method "{0}" for interceptors {1}.

# fail("MethodPermission", "methodPermission.ejbNameRequired", method.getMethodName(), join(permission.getRoleName(), ","));
1.methodPermission.ejbNameRequired =  ejb-name required for method-permission
2.methodPermission.ejbNameRequired =  ejb-name required for method-permission: {0}
3.methodPermission.ejbNameRequired =  Assinging a method-permission requires the ejb-name of the bean to also be specified.  Fix method-permission on method "{0}" for security roles {1}.

# fail("MethodPermission", "methodPermission.noSuchEjbName", method.getEjbName(), method.getMethodName(), join(permission.getRoleName(), ","));
1.methodPermission.noSuchEjbName = Referenced EJB does not exist
2.methodPermission.noSuchEjbName = Referenced EJB does not exist: {0} on method "{1}".
3.methodPermission.noSuchEjbName = Method-permission refers to an EJB, {0}, that does not exist.  Fix method-permission on method "{0}" for security roles {1}.

# fail("ContainerTransaction", "containerTransaction.ejbNameRequired", method.getMethodName(), transaction.getTransAttribute());
1.containerTransaction.ejbNameRequired = ejb-name required for container-transaction
2.containerTransaction.ejbNameRequired = ejb-name required for container-transaction: {0}
3.containerTransaction.ejbNameRequired = Assinging a container-transaction requires the ejb-name of the bean to also be specified.  Fix container-transaction on method "{0}" with transaction attribute {1}.

# fail("ContainerTransaction", "containerTransaction.noSuchEjbName", method.getMethodName(), method.getEjbName(), transaction.getTransAttribute());
1.containerTransaction.noSuchEjbName = Referenced EJB does not exist
2.containerTransaction.noSuchEjbName = Referenced EJB does not exist: {0} on method "{1}".
3.containerTransaction.noSuchEjbName = Container-transaction refers to an EJB, {0}, that does not exist.  Fix container-transaction on method "{0}" with transaction attribute {1}.

# CheckCallbacks.java
# fail(componentName, "aroundInvoke.badReturnType", aroundType, aroundInvoke.getMethodName(), returnType.getName(), aroundInvoke.getClassName());
1.aroundInvoke.badReturnType = {0} method must return java.lang.Object
2.aroundInvoke.badReturnType = {0} method must return java.lang.Object: method "{1}" returns "{2}"
3.aroundInvoke.badReturnType = {0} method "{1}" in class {3} illegally returns {2} instead of java.lang.Object.  Change the method signature to "java.lang.Object {1}(javax.ejb.InvocationContext) throws java.lang.Exception"

# fail(componentName, "aroundInvoke.mustThrowException", aroundType, aroundInvoke.getMethodName(), aroundInvoke.getClassName());
1.aroundInvoke.mustThrowException = {0} method must declare 'throws Exception'
2.aroundInvoke.mustThrowException = {0} method must declare 'throws Exception': method "{1}"
3.aroundInvoke.mustThrowException = {0} method "{1}" must declare java.lang.Exception in the throws clause.  Change the method signature to "java.lang.Object {1}(javax.ejb.InvocationContext) throws java.lang.Exception"

# fail(componentName, "aroundInvoke.missing", aroundType, aroundInvoke.getMethodName(), aroundInvoke.getClassName());
1.aroundInvoke.missing = {0} method missing
2.aroundInvoke.missing = {0} method missing: "{1}" in class {2}
3.aroundInvoke.missing = {0} method "{1}" not found in class {2}.  The required method signature is "java.lang.Object {1}(javax.ejb.InvocationContext) throws java.lang.Exception"

# fail(componentName, "aroundInvoke.invalidArguments", aroundType, aroundInvoke.getMethodName(), getParameters(possibleMethods.get(0)), aroundInvoke.getClassName());
1.aroundInvoke.invalidArguments = Invalid {0} arguments
2.aroundInvoke.invalidArguments = Invalid {0} arguments: {1}({2})
3.aroundInvoke.invalidArguments = {0} method signature "{1}({2})" in class {3} has invalid arguments.  The required method signature is "java.lang.Object {1}(javax.ejb.InvocationContext) throws java.lang.Exception"

# fail(componentName, "aroundInvoke.missing.possibleTypo", aroundType, aroundInvoke.getMethodName(), possibleMethods.size(), aroundInvoke.getClassName());
1.aroundInvoke.missing.possibleTypo = {0} method missing or invalid
2.aroundInvoke.missing.possibleTypo = {0} method missing or invalid: looked for "{1}(javax.ejb.InvocationContext)" in class {3}
3.aroundInvoke.missing.possibleTypo = {0} method missing or invalid.  There are {2} methods with the name "{1}" visible in class {3}, none have the required signature of "java.lang.Object {1}(javax.ejb.InvocationContext) throws java.lang.Exception"

# fail(bean, "callback.badReturnType", type, callback.getMethodName(), returnType.getName(), callback.getClassName());
1.callback.badReturnType = {0} method must return 'void'
2.callback.badReturnType = {0} method must return 'void': method {1} returns {2}
3.callback.badReturnType = {0} method "{1}" in class {3} illegally returns {2} instead of void.  Change the method signature to "void {1}()"

# fail(bean, "callback.badModifier", type, callback.getMethodName(), callback.getClassName());
1.callback.badModifier = {0} method must not be final and static
2.callback.badModifier = {0} method must not be final and static : method {1}
3.callback.badModifier = {0} method "{1}" in class {2} must not be final and static

# fail(bean, "callback.missing", type, callback.getMethodName(), callback.getClassName());
1.callback.missing = {0} method missing
2.callback.missing = {0} method missing: "{1}" in class {2}
3.callback.missing = {0} method "{1}" not found in class {2}.  The required method signature is "void {1}()"

# fail(bean, "callback.invalidArguments", type, callback.getMethodName(), getParameters(possibleMethods.get(0)), callback.getClassName());
1.callback.invalidArguments = Invalid {0} arguments
2.callback.invalidArguments = Invalid {0} arguments. Found: {1}({2}). Required: {1}({4}) 
3.callback.invalidArguments = {0} method signature "{1}({2})" in class {3} has invalid arguments.  The required method signature is "void {1}(4)"

# fail(bean, "callback.missing.possibleTypo", type, callback.getMethodName(), possibleMethods.size(), callback.getClassName());
1.callback.missing.possibleTypo = {0} method missing or invalid
2.callback.missing.possibleTypo = {0} method missing or invalid: looked for "void {1}({4})" in class {3}
3.callback.missing.possibleTypo = {0} method missing or invalid.  There are {2} methods with the name "{1}" visible in class {3}, none have the required signature of "void {1}(4)"

# fail(bean, "callback.sessionSynchronization.invalidUse", class)
1.callback.sessionSynchronization.invalidUse = Session synchronization annotations and configurations in deployment plan should not be used while SessionSynchronization interface is implemented by the bean class.
2.callback.sessionSynchronization.invalidUse = Session synchronization annotations and configurations in deployment plan should not be used while SessionSynchronization interface is implemented by the bean class {0}.
3.callback.sessionSynchronization.invalidUse = Session synchronization annotations and configurations in deployment plan should not be used while SessionSynchronization interface is implemented by the bean class {0}.

# fail(bean, "callback.missing.possibleTypo", type, callback.getMethodName(), possibleMethods.size(), callback.getClassName());
1.callback.sessionbean.invalidusage = Invalid usage of @{0} in a class which implements javax.ejb.SessionBean
2.callback.sessionbean.invalidusage = Invalid usage of @{0} in a class which implements javax.ejb.SessionBean
3.callback.sessionbean.invalidusage = Invalid usage of @{0} in {2} which implements javax.ejb.SessionBean. @{0} was wrongly used on the method {1}(). The usage would have been correct if {2} did not implement javax.ejb.SessionBean.

# fail(bean, "timeout.badReturnType", callback.getMethodName(), returnType.getName());
1.timeout.badReturnType = Timeout method must return 'void'
2.timeout.badReturnType = Timeout method must return 'void': method {0} returns {1}
3.timeout.badReturnType = Timeout method "{0}" illegally returns {1} instead of void.  Change the method signature to "void {0}(javax.ejb.Timer)"

#Don't think this is ever going to be used, commenting it out for now. If there is a case where this key can be used, please uncomment it and write a test for it
# fail(bean, "timeout.missing", timeout.getMethodName());
#1.timeout.missing = Timeout method missing
#2.timeout.missing = Timeout method missing: "{0}" in class {1}
#3.timeout.missing = Timeout method "{0}" not found in class {1}.  The required method signature is "void {0}(javax.ejb.Timer)"

# fail(bean, "timeout.invalidArguments", timeout.getMethodName(), getParameters(possibleMethods.get(0)));
1.timeout.invalidArguments = Invalid Timeout arguments
2.timeout.invalidArguments = Invalid Timeout arguments: {0}({1})
3.timeout.invalidArguments = Timeout method signature "{0}({1})" has invalid arguments.  The required method signature is "void {0}(javax.ejb.Timer)"

# fail(bean, "timeout.missing.possibleTypo", timeout.getMethodName(), possibleMethods.size());
1.timeout.missing.possibleTypo = Timeout method missing or invalid
2.timeout.missing.possibleTypo = Timeout method missing or invalid: looked for "void {0}(javax.ejb.Timer)"
3.timeout.missing.possibleTypo = Timeout method missing or invalid.  There are {1} methods with the name "{0}" visible, either the wrong one has been annotated with @Timeout or none have the required signature of "void {0}(javax.ejb.Timer). A bean should have only one method annotated with @Timeout and the method signature must match void {0}(javax.ejb.Timer)"

# fail(componentName,"timeout.tooManyMethods",timeoutMethods.size(),Join.join(",", timeoutMethods));
1.timeout.tooManyMethods = More than one method annotated with @Timeout
2.timeout.tooManyMethods = More than one method annotated with @Timeout
3.timeout.tooManyMethods = More than one method annotated with @Timeout.  There are {0} methods annotated with @Timeout. Make sure you have only one method annotated with @Timeout. Methods annotated with @Timeout are {1}
# fail("Interceptor", "interceptor.callback.badReturnType", type, callback.getMethodName(), returnType.getName(), interceptorClass.getName());
1.interceptor.callback.badReturnType = {0} method must return "void"
2.interceptor.callback.badReturnType = {0} method must return "void": method {2} returns {3} instead
3.interceptor.callback.badReturnType = method "{2}" in class {0} illegally returns {3} instead of void.  Change the method signature to "void {2}(javax.ejb.InvocationContext)"

# fail("Interceptor", "interceptor.callback.missing", type, callback.getMethodName(), interceptorClass.getName());
1.interceptor.callback.missing = {0} method missing
2.interceptor.callback.missing = {0} method missing: "{1}" in class {2}
3.interceptor.callback.missing = {0} method "{1}" not found in class {2}.  The required method signature is "void {1}(javax.ejb.InvocationContext)"

# fail("Interceptor", "interceptor.callback.invalidArguments", type, callback.getMethodName(), getParameters(possibleMethods.get(0)), interceptorClass.getName());
1.interceptor.callback.invalidArguments = Invalid {0} arguments
2.interceptor.callback.invalidArguments = Invalid {0} arguments: {1}({2}) in class {3}
3.interceptor.callback.invalidArguments = {0} method signature "{1}({2})" in class {3} has invalid arguments.  The required method signature is "void {1}(javax.ejb.InvocationContext)"

# fail("Interceptor", "interceptor.callback.missing.possibleTypo", type, callback.getMethodName(), possibleMethods.size(), interceptorClass.getName());
1.interceptor.callback.missing.possibleTypo = {0} method missing or invalid
2.interceptor.callback.missing.possibleTypo = {0} method missing or invalid: looked for "void {1}(javax.ejb.InvocationContext)" in class {3}
3.interceptor.callback.missing.possibleTypo = {0} method missing or invalid.  There are {2} methods with the name "{1}" visible in class {3}, none have the required signature of "void {1}()"

#CheckAssemblyBindings.java
# warn("Interceptors", "interceptor.unused", clazz);
1.interceptor.unused = {0} is not intercepting any bean
2.interceptor.unused = {0} is not intercepting any bean. It should be used in one of the interceptor-binding elements of the deployment descriptor.
3.interceptor.unused = {0} is not intercepting any bean. It should be used in one of the interceptor-binding elements of the deployment descriptor. An example usage might be:\r\n\
<interceptor-binding>\r\n\
\u0020\u0020<ejb-name>Your ejb name here</ejb-name>\r\n\
\u0020\u0020<interceptor-class>{0}</interceptor-class>\r\n\
<interceptor-binding>

# CheckInjectionTargets.java
# warn(bean, "injectionTarget.nameContainsSet", target.getInjectionTargetName(), shortNameInvalid, shortNameCorrect, correctName, reference.getName(), reference.getClass().getSimpleName());
1.injectionTarget.nameContainsSet = Corrected invalid injection-target-name
2.injectionTarget.nameContainsSet = Corrected invalid injection-target-name: {0}
3.injectionTarget.nameContainsSet = The injection-target-name "{0}" for setter methods should not begin with "set".  The last portion of the name "{1}" has been automatically corrected to "{2}".  Update the descriptor with the correct injection-target-name of "{3}" to avoid receiving this warning.  Resource to be injected is "{4}".

# fail("Asynchronous", "asynchronous.badReturnType", asyncMethod.getMethodName(), returnType.getName(), beanClass.getName());
1.asynchronous.badReturnType = asynchronous method must return "void" or "Future<V>"
2.asynchronous.badReturnType = asynchronous} method must return "void" or "Future<V>" : method {0} returns {1} in class {2}
3.asynchronous.badReturnType = asynchronous method "{0}" in class {2} illegally returns {1} instead of void or Future<V>.  Change the method signature to "void|Future<V> {0}(...)"

# fail("Asynchronous", "asynchronous.missing", asyncMethod.getMethodName(), beanClass.getName(), getParamters(asyncMethod));
1.asynchronous.missing = asynchronous method {0} missing
2.asynchronous.missing = asynchronous method missing: "{0}" in class {1}
3.asynchronous.missing = asynchronous method "{1}" not found in class {1}.  The required method signature is "void|Future<V> {0}({2})"

# fail("Asynchronous", "asynchronous.missing", asyncMethod.getMethodName(), beanClass.getName(), getParamters(asyncMethod));
1.asynchronous.badExceptionType = asynchronous method {0} should not throw any ApplicationException while its return type is void.
2.asynchronous.badExceptionType = asynchronous method {0} in class {1} should not throw any ApplicationException while its return type is void.
3.asynchronous.badExceptionType = asynchronous method {0} in class {1} should not throw ApplicationException "{2}" while its return type is void.

# warn("Asynchronous", "asynchronous.methodignored", beanClass.getName(), methodName);
1.asynchronous.methodignored = non-public method {1} in class {0} is ignored, although the class is annoated with @Asynchronous
2.asynchronous.methodignored = non-public method {1} in class {0} is ignored, although the class is annoated with @Asynchronous
3.asynchronous.methodignored = non-public method {1} in class {0} is ignored, although the class is annoated with @Asynchronous

# AnnotationDeployer.java
# warn("client.missingMainClass", className)
# fail("client.missingMainClass", className)
1.client.missingMainClass = Missing Main-Class
2.client.missingMainClass = Missing Main-Class: {0}
3.client.missingMainClass = The Main-Class {0} specified in the MANIFEST.MF file does not exist in the jar.

# fail(ejbName, "xml.localRemote.conflict", interfce);
1.xml.localRemote.conflict = Interface illegally declared as both <business-local> and <business-remote>.
2.xml.localRemote.conflict = Interface illegally declared as both <business-local> and <business-remote>: {0}
3.xml.localRemote.conflict = When declaring business interface as <business-local> in an ejb-jar.xml file, the same interface cannot be listed as <business-remote>.  Revise the declaration of business interface "{0}" so that it is either local or remote, not both.

# fail(ejbName, "xml.localRemote.conflict", interfce);
1.ann.localRemote.generalconflict = Interface illegally declared as both local and remote in some combination of xml and annotations.
2.ann.localRemote.generalconflict = Interface illegally declared as both local and remote in some combination of xml and annotations: {0}
3.ann.localRemote.generalconflict = When declaring business interface as local in xml or annotations, the same interface cannot be listed as remote.  Revise the declaration of business interface "{0}" so that it is either local or remote, not both.

# fail(ejbName, "ann.remote.noAttributes", join(", ", interfaces));
1.ann.remote.noAttributes = Ambiguous @Remote() usage on bean class
2.ann.remote.noAttributes = Ambiguous @Remote() usage on bean class.  Must list interfaces explicitly in annotation.
3.ann.remote.noAttributes = When annotating a bean class as @Remote with no annotation attributes, the bean must implement exactly one business interface, no more and no less.  List the remote interfaces explicitly in the annotation, such as @Remote('{'{0}'}').  Alternatively, apply the @Remote annotation to the individual interfaces and remove it from the bean class.

#This one is the same as ann.localremote.ambiguous -- commenting it out for now
# fail(ejbName, "ann.remoteLocal.ambiguous", join(", ", interfaces));
#1.ann.remoteLocal.ambiguous = Ambiguous @Remote and @Local usage on bean class.
#2.ann.remoteLocal.ambiguous = Ambiguous @Remote and @Local usage on bean class.  Must list interfaces explicitly in @Remote annotation.
#3.ann.remoteLocal.ambiguous = When annotating a bean class as @Remote with no annotation attributes you must not also annotate it with @Local with no attributes.  List the remote interfaces explicitly in the annotation, such as @Remote(\{{0}\}).  Alternatively, apply the @Remote annotation to the individual interfaces and remove it from the bean class.

# This one is not used anywhere in code and is the same as ann.localRemote.conflict -- commenting it out for now
# fail(ejbName, "ann.remoteLocal.conflict", join(", ", interfaces));
#1.ann.remoteLocal.conflict = @Remote annotation in bean class conflicts with @Local in interface.
#2.ann.remoteLocal.conflict = @Remote annotation in bean class conflicts with @Local in interface "{0}".
#3.ann.remoteLocal.conflict = When annotating a bean class as @Remote, the corresponding business interfaces cannot be annotated with @Local.  Revise the business interface "{0}".

# fail(ejbName, "ann.local.noAttributes", join(", ", interfaces));
1.ann.local.noAttributes = Ambiguous @Local() usage on bean class
2.ann.local.noAttributes = Ambiguous @Local() usage on bean class.  Must list interfaces explicitly in annotation.
3.ann.local.noAttributes = When annotating a bean class as @Local with no annotation attributes, the bean must implement exactly one business interface, no more and no less.  List the local interfaces explicitly in the annotation, such as @Local('{'{0}'}').  Alternatively, apply the @Local annotation to the individual interfaces and remove it from the bean class.

# fail(ejbName, "ann.localRemote.ambiguous", join(", ", interfaces));
1.ann.localRemote.ambiguous = Ambiguous @Local and @Remote usage on bean class.
2.ann.localRemote.ambiguous = Ambiguous @Local and @Remote usage on bean class.  Must list interfaces explicitly in @Local annotation.
3.ann.localRemote.ambiguous = When annotating a bean class as @Local with no annotation attributes you must not also annotate it with @Remote.  List the local interfaces explicitly in the annotation, such as @Local('{'{0}'}').  Alternatively, apply the @Local annotation to the individual interfaces and remove it from the bean class.

# fail(ejbName, "ann.localRemote.conflict", join(", ", interfaces));
1.ann.localRemote.conflict = @Local annotation in bean class conflicts with @Remote in interface.
2.ann.localRemote.conflict = @Local annotation in bean class conflicts with @Remote in interface "{0}".
3.ann.localRemote.conflict = When annotating a bean class as @Local, the corresponding business interfaces cannot be annotated with @Remote.  Revise the business interface "{0}".

# fail(ejbName, "ann.remoteOrLocal.ejbHome", annotationName, interfce.getName());
1.ann.remoteOrLocal.ejbHome = @{0} used in bean class lists a javax.ejb.EJBHome interface.
2.ann.remoteOrLocal.ejbHome = @{0} used in bean class lists a javax.ejb.EJBHome interface. Use @RemoteHome({1})
3.ann.remoteOrLocal.ejbHome = When applied to a bean class, the @{0} annotation must only list business interfaces and cannot list legacy EJBHome interfaces.  EJBHome interfaces can be annotated on the bean class with @RemoteHome({1})

# fail(ejbName, "ann.remoteOrLocal.ejbLocalHome", annotationName, interfce.getName());
1.ann.remoteOrLocal.ejbLocalHome = @{0} used in bean class lists a javax.ejb.EJBLocalHome interface.
2.ann.remoteOrLocal.ejbLocalHome = @{0} used in bean class lists a javax.ejb.EJBLocalHome interface. Use @LocalHome({1})
3.ann.remoteOrLocal.ejbLocalHome = When applied to a bean class, the @{0} annotation must only list business interfaces and cannot list legacy EJBLocalHome interfaces.  EJBLocalHome interfaces can be annotated on the bean class with @LocalHome({1})

# fail(ejbName, "ann.remoteOrLocal.ejbObject", annotationName, interfce.getName());
1.ann.remoteOrLocal.ejbObject = @{0} used in bean class lists a javax.ejb.EJBObject interface.
2.ann.remoteOrLocal.ejbObject = @{0} used in bean class lists a javax.ejb.EJBObject interface. Use @RemoteHome with home interface of "{1}".
3.ann.remoteOrLocal.ejbObject = When applied to a bean class, the @{0} annotation must only list business interfaces and cannot list legacy EJBObject interfaces.  The EJBHome of interface for "{1}" can be annotated on the bean class with @RemoteHome

# fail(ejbName, "ann.remoteOrLocal.ejbLocalObject", annotationName, interfce.getName());
1.ann.remoteOrLocal.ejbLocalObject = @{0} used in bean class lists a javax.ejb.EJBLocalObject interface.
2.ann.remoteOrLocal.ejbLocalObject = @{0} used in bean class lists a javax.ejb.EJBLocalObject interface. Use @LocalHome with home interface of "{1}".
3.ann.remoteOrLocal.ejbLocalObject = When applied to a bean class, the @{0} annotation must only list business interfaces and cannot list legacy EJBLocalObject interfaces.  The EJBLocalHome of interface for "{1}" can be annotated on the bean class with @LocalHome

# fail(ejbName, "ann.remoteOrLocal.ejbLocalObject", annotationName, interfce.getName());
1.ann.remoteOrLocal.converse.parent = Interface annotated @Local or @Remote is annotated conversely in parent interface.
2.ann.remoteOrLocal.converse.parent = Interface annotated @Local or @Remote is annotated conversely in parent interface. Fix it by annotating both the interfaces with the same annotation
3.ann.remoteOrLocal.converse.parent = Interface {0} is annotated with @{1} whereas its parent interface {2} is annotated with @{3}. Ensure that both the interfaces are either annotated with @{1} or @{3}. An example would be:\r\n\
@{1}\r\n\
public interface {2}'{}'\r\n\
@{1}\r\n\
public interface {0} extends {2}'{}'

# warn(bean, "ignoredMethodAnnotation", annotationType, beanType, className, methodName);
1.ignoredMethodAnnotation = @{0} is ignored for beans of type {1}
2.ignoredMethodAnnotation = @{0} is ignored for beans of type {1}.  Class: {2} Method: {3}
3.ignoredMethodAnnotation = Beans of type {1} are not allowed to use the @{0} annotation.  This annotation is only permitted on {1} beans.  The usage of @{0} on bean class {2} method {3} will be ignored and the annotation should be removed.

# warn(bean, "ignoredClassAnnotation", annotationType, beanType, className);
1.ignoredClassAnnotation = @{0} is ignored for beans of type {1}
2.ignoredClassAnnotation = @{0} is ignored for beans of type {1}.  Class: {2}
3.ignoredClassAnnotation = Beans of type {1} are not allowed to use the @{0} annotation.  This annotation is only permitted on {1} beans.  The usage of @{0} on bean class {2} will be ignored and the annotation should be removed.

# fail(bean, "persistenceContextExtented.nonStateful", refName, beanType);
1.persistenceContextExtented.nonStateful = Non-Stateful use of PersistenceContextType.EXTENDED
2.persistenceContextExtented.nonStateful = Non-Stateful use of PersistenceContextType.EXTENDED in ref {0}
3.persistenceContextExtented.nonStateful = {1} ejbs are not capable of using EntityManagers with EXTENTED persistence.  Convert your bean to a Stateful ejb or update the "{0}" PersistenceContext reference to PersistenceContextType.TRANSACTION.

# fail(consumer.getJndiConsumerName(), "resourceRef.onEntityManager", refName);
1.resourceRef.onEntityManager = Mistaken use of @Resource on an EntityManager reference.  Use @PersistenceContext.
2.resourceRef.onEntityManager = Mistaken use of @Resource on an EntityManager reference.  Use @PersistenceContext for ref "{0}"
3.resourceRef.onEntityManager = The @Resource annotation cannot be used on references to javax.persistence.EntityManager.  Change the annotation to @PersistenceContext for ref "{0}"

# fail(consumer.getJndiConsumerName(), "resourceRef.onEntityManagerFactory", refName);
1.resourceRef.onEntityManagerFactory = Mistaken use of @Resource on an EntityManagerFactory reference.  Use @PersistenceUnit.
2.resourceRef.onEntityManagerFactory = Mistaken use of @Resource on an EntityManagerFactory reference.  Use @PersistenceUnit for ref "{0}"
3.resourceRef.onEntityManagerFactory = The @Resource annotation cannot be used on references to javax.persistence.EntityManagerFactory.  Change the annotation to @PersistenceUnit for ref "{0}"

# fail(consumer.getJndiConsumerName(), "ejbAnnotation.onClassWithNoBeanInterface");
1.ejbAnnotation.onClassWithNoBeanInterface = Missing required "beanInterface" attribute on class-level @EJB usage
2.ejbAnnotation.onClassWithNoBeanInterface = Missing required "beanInterface" attribute on class-level @EJB usage
3.ejbAnnotation.onClassWithNoBeanInterface = The "beanInterface" attribute was not specified for the class level annotation @EJB. It is mandatory for all class level @EJB annotations.

# fail(consumer.getJndiConsumerName(), "ejbAnnotation.onClassWithNoName");
1.ejbAnnotation.onClassWithNoName = Missing required "name" attribute on class-level @EJB usage
2.ejbAnnotation.onClassWithNoName = Missing required "name" attribute on class-level @EJB usage
3.ejbAnnotation.onClassWithNoName = The "name" attribute was not specified for the class level annotation @EJB. It is mandatory for all class level @EJB annotations.

# fail(consumer.getJndiConsumerName(), "persistenceContextAnnotation.onEntityManagerFactory", persistenceContextRef.getName());
1.persistenceContextAnnotation.onEntityManagerFactory = Mistaken use of @PersistenceContext on an EntityManagerFactory reference.  Use @PersistenceUnit.
2.persistenceContextAnnotation.onEntityManagerFactory = Mistaken use of @PersistenceContext on an EntityManagerFactory reference.  Use @PersistenceUnit for ref "{0}"
3.persistenceContextAnnotation.onEntityManagerFactory =  The @PersistenceContext annotation only applies to javax.persistence.EntityManager and cannot be used on references to javax.persistence.EntityManagerFactory.  Change the annotation to @PersistenceUnit for ref "{0}"

# fail(consumer.getJndiConsumerName(), "persistenceContextAnnotation.onNonEntityManager", persistenceContextRef.getName());
1.persistenceContextAnnotation.onNonEntityManager = Use of @PersistenceContext only applies to EntityManager references
2.persistenceContextAnnotation.onNonEntityManager = Use of @PersistenceContext only applies to EntityManager references.  Fix ref "{0}"
3.persistenceContextAnnotation.onNonEntityManager = The @PersistenceContext annotation only applies to javax.persistence.EntityManager and cannot be used on references of other types.  Change the annotation for ref "{0}"

# fail(consumer.getJndiConsumerName(), "persistenceUnitAnnotation.onEntityManager", persistenceUnitRef.getName());
1.persistenceUnitAnnotation.onEntityManager = Mistaken use of @PersistenceUnit on an EntityManager reference.  Use @PersistenceContext
2.persistenceUnitAnnotation.onEntityManager = Mistaken use of @PersistenceUnit on an EntityManager reference.  Use @PersistenceContext for ref "{0}"
3.persistenceUnitAnnotation.onEntityManager = The @PersistenceUnit annotation only applies to javax.persistence.EntityManagerFactory and cannot be used on references to javax.persistence.EntityManager.  Change the annotation to @PersistenceContext for ref "{0}"

# fail(consumer.getJndiConsumerName(), "persistenceUnitAnnotation.onNonEntityManagerFactory", persistenceUnitRef.getName());
1.persistenceUnitAnnotation.onNonEntityManagerFactory = Use of @PersistenceUnit only applies to EntityManager references
2.persistenceUnitAnnotation.onNonEntityManagerFactory = Use of @PersistenceUnit only applies to EntityManager references.  Fix ref "{0}"
3.persistenceUnitAnnotation.onNonEntityManagerFactory = The @PersistenceUnit annotation only applies to javax.persistence.EntityManagerFactory and cannot be used on references of other types.  Change the annotation for ref "{0}"

# fail(consumer.getJndiConsumerName(), "resourceAnnotation.onClassWithNoName");
1.resourceAnnotation.onClassWithNoName = Missing required "name" attribute on class-level @Resource usage
2.resourceAnnotation.onClassWithNoName = Missing required "name" attribute on class-level @Resource usage
3.resourceAnnotation.onClassWithNoName = The "name" attribute was not specified for the class level annotation @Resource. It is mandatory for all class level @Resource annotations.

# fail(consumer.getJndiConsumerName(), "resourceAnnotation.onClassWithNoType");
1.resourceAnnotation.onClassWithNoType = Missing required "type" attribute on class-level @Resource usage
2.resourceAnnotation.onClassWithNoType = Missing required "type" attribute on class-level @Resource usage
3.resourceAnnotation.onClassWithNoType = The "type" attribute was not specified for the class level annotation @Resource. It is mandatory for all class level @Resource annotations.

# fail(consumer.getJndiConsumerName(), "persistenceContextAnnotation.onClassWithNoName", persistenceContext.unitName());
1.persistenceContextAnnotation.onClassWithNoName = Missing required "name" attribute on class-level @PersistenceContext usage
2.persistenceContextAnnotation.onClassWithNoName = Missing required "name" attribute on class-level @PersistenceContext usage.
3.persistenceContextAnnotation.onClassWithNoName = The "name" attribute was not specified for the class level annotation @PersistenceContext with unitName="{0}". It is mandatory for all class level @PersistenceContext annotations.

# fail(consumer.getJndiConsumerName(), "persistenceUnitAnnotation.onClassWithNoName", persistenceUnit.unitName());
1.persistenceUnitAnnotation.onClassWithNoName = Missing required "name" attribute on class-level @PersistenceUnit usage
2.persistenceUnitAnnotation.onClassWithNoName = Missing required "name" attribute on class-level @PersistenceUnit usage.
3.persistenceUnitAnnotation.onClassWithNoName = The "name" attribute was not specified for the class level annotation @PersistenceUnit with unitName="{0}". It is mandatory for all class level @PersistenceUnit annotations.


# AutoConfig.java
# fail(componentName, "persistenceContextRef.noPersistenceUnits", refShortName, unitName);
1.persistenceContextRef.noPersistenceUnits = Missing required persistence.xml for @PersistenceContext ref
2.persistenceContextRef.noPersistenceUnits = Missing required persistence.xml for @PersistenceContext ref "{0}" to unit "{1}"
3.persistenceContextRef.noPersistenceUnits = A persistence unit must be defined via META-INF/persistence.xml to satisfy @PersistenceContext ref "{0}" to unit "{1}".  An example of a suitable persistence.xml might be:\
  <persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">\
    <persistence-unit name="{1}">\
      <jta-data-source>java:openejb/Resource/myDataSource</jta-data-source>\
      <non-jta-data-source>java:openejb/Resource/myUnmanagedDataSource</non-jta-data-source>\
\
        <properties>\
        <property name="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true)"/>\
      </properties>\
    </persistence-unit>\
  </persistence>\


# fail(componentName, "persistenceContextRef.noUnitName", refShortName, join(", ", availableUnits), sampleUnitName );
1.persistenceContextRef.noUnitName = @PersistenceContext unitName required, multiple units available.
2.persistenceContextRef.noUnitName = @PersistenceContext unitName required, multiple units available: ref "{0}", available units [{1}]
3.persistenceContextRef.noUnitName = Use of @PersistenceContext without a unitName is only allowed when there is only a single persistence.xml in the entire application defining exactly one persistence-unit.  Available units for ref {0} are [{1}].  Add the unitName to your declaration, for example:\
    @PersistenceContext(name="{0}", unitName = "{2}")

# fail(componentName, "persistenceContextRef.vagueMatches", refShortName, unitName, possibleUnits.size(), join(", ", possibleUnits));
1.persistenceContextRef.vagueMatches = @PersistenceContext unitName has multiple matches.
2.persistenceContextRef.vagueMatches = @PersistenceContext unitName has multiple matches: unitName "{1}" has {2} possible matches.
3.persistenceContextRef.vagueMatches = The reference @PersistenceContext(name="{0}", unitName="{1}") cannot be resolved as there are {2} units with the same name.  Update your unitName to one of the following:\
{3}

# fail(componentName, "persistenceContextRef.noMatches", refShortName, unitName, join(", ", availableUnits));
1.persistenceContextRef.noMatches = Persistence unit not found
2.persistenceContextRef.noMatches = Persistence unit not found for @PersistenceContext(name="{0}", unitName="{1}").  Available units [{2}]
3.persistenceContextRef.noMatches = The persistence unit "{1}" does not exist.  Update the "{0}" PersistenceContext ref to one of the available units [{2}] or declare the unit in a persistence.xml like the following:\
  <persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">\
    <persistence-unit name="{1}">\
      <jta-data-source>java:openejb/Resource/myDataSource</jta-data-source>\
      <non-jta-data-source>java:openejb/Resource/myUnmanagedDataSource</non-jta-data-source>\
\
        <properties>\
        <property name="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true)"/>\
      </properties>\
    </persistence-unit>\
  </persistence>\


# fail(componentName, "persistenceUnitRef.noPersistenceUnits", refShortName, unitName);
1.persistenceUnitRef.noPersistenceUnits = Missing required persistence.xml for @PersistenceUnit ref
2.persistenceUnitRef.noPersistenceUnits = Missing required persistence.xml for @PersistenceUnit ref "{0}" to unit "{1}"
3.persistenceUnitRef.noPersistenceUnits = A persistence unit must be defined via META-INF/persistence.xml to satisfy @PersistenceUnit ref "{0}" to unit "{1}".  An example of a suitable persistence.xml might be:\
  <persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">\
    <persistence-unit name="{1}">\
      <jta-data-source>java:openejb/Resource/myDataSource</jta-data-source>\
      <non-jta-data-source>java:openejb/Resource/myUnmanagedDataSource</non-jta-data-source>\
\
        <properties>\
        <property name="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true)"/>\
      </properties>\
    </persistence-unit>\
  </persistence>\


# fail(componentName, "persistenceUnitRef.noUnitName", refShortName, join(", ", availableUnits), sampleUnitName );
1.persistenceUnitRef.noUnitName = @PersistenceUnit unitName required, multiple units available.
2.persistenceUnitRef.noUnitName = @PersistenceUnit unitName required, multiple units available: ref "{0}", available units [{1}]
3.persistenceUnitRef.noUnitName = Use of @PersistenceUnit witout a unitName is only allowed when there is only a single persistence.xml in the entire application defining exactly one persistence-unit.  Available units for ref {0} are [{1}].  Add the unitName to your declaration, for example:\
    @PersistenceUnit(name="{0}", unitName = "{2}")

# fail(componentName, "persistenceUnitRef.vagueMatches", refShortName, unitName, possibleUnits.size(), join(", ", possibleUnits));
1.persistenceUnitRef.vagueMatches = @PersistenceUnit unitName has multiple matches.
2.persistenceUnitRef.vagueMatches = @PersistenceUnit unitName has multiple matches: unitName "{1}" has {2} possible matches.
3.persistenceUnitRef.vagueMatches = The reference @PersistenceUnit(name="{0}", unitName="{1}") cannot be resolved as there are {2} units with the same name.  Update your unitName to one of the following:\
{3}

# fail(componentName, "persistenceUnitRef.noMatches", refShortName, unitName, join(", ", availableUnits));
1.persistenceUnitRef.noMatches = Persistence unit not found
2.persistenceUnitRef.noMatches = Persistence unit not found for ref @PersistenceUnit(name="{0}", unitName="{1}").  Available units [{2}]
3.persistenceUnitRef.noMatches = The persistence unit "{1}" does not exist.  Update the "{0}" PersistenceUnit ref to one of the available units [{2}] or declare the unit in a persistence.xml like the following:\
  <persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">\
    <persistence-unit name="{1}">\
      <jta-data-source>java:openejb/Resource/myDataSource</jta-data-source>\
      <non-jta-data-source>java:openejb/Resource/myUnmanagedDataSource</non-jta-data-source>\
\
        <properties>\
        <property name="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true)"/>\
      </properties>\
    </persistence-unit>\
  </persistence>\


# fail(ejbName, "interfaceAnnotatedAsBean", annotationClass.getSimpleName(), beanClass.getName());
1.interfaceAnnotatedAsBean = @{0} cannot be applied to an interface.
2.interfaceAnnotatedAsBean = @{0} cannot be applied to an interface: {1}
3.interfaceAnnotatedAsBean = Only concrete classes, not interfaces, are allowed to use the @{0} annotation.  Either convert the interface {1} to a class so that it may be used as a valid bean or move the @{0} annotation to the classes that implement this interface.

# fail(ejbName, "abstractAnnotatedAsBean", annotationClass.getSimpleName(), beanClass.getName());
1.abstractAnnotatedAsBean = @{0} cannot be applied to abstract classes.
2.abstractAnnotatedAsBean = @{0} cannot be applied to an abstract class: {1}
3.abstractAnnotatedAsBean = Only concrete classes, not abstract classes, are allowed to use the @{0} annotation.  Either convert the abstract class {1} to a concrete class so that it may be used as a valid bean or move the @{0} annotation to the classes that subclass from this class.

# fail(ejbName, "multiplyAnnotatedAsBean", annotationClass.getSimpleName(), secondAnnotation.getSimpleName(), ejbName, beanClass.getName())
1.multiplyAnnotatedAsBean = Identical 'name' used in both @{0} and @{1} annotations.
2.multiplyAnnotatedAsBean = Identical 'name' used in both @{0} and @{1} annotations: name={2}
3.multiplyAnnotatedAsBean = When attempting to deploy a bean as both @{0} and @{1} different values must be used for the 'name' attributes as all ejb-names must be unique within a given ejb-jar.  Update the @{1} annotation to explicitly set the 'name' attribute to a different value.  For example: @{1}(name = "{1}{2}")

# fail(b, "noInterfaceDeclared.entity", ejbClass.getSimpleName());
1.noInterfaceDeclared.entity = EJBHome or EJBLocalHome interface required.
2.noInterfaceDeclared.entity = EJBHome or EJBLocalHome interface required.
3.noInterfaceDeclared.entity = EJB 2.x and 1.x entity beans require EJBHome or EJBLocalHome interfaces to be accessed.  An example of valid component (i.e. pre-EJB 3.0) interfaces for this bean might be:\
    public interface {0}Home extends javax.ejb.EJBLocalHome '\u007B' \
        {0}Object create() throws javax.ejb.CreateException;        \
    '\u007D' \
\
    public interface {0}Object extends javax.ejb.EJBLocalObject '\u007B' \
        \
    '\u007D' \

#This is no longer used in code -- commenting out for now
# fail(b, "noInterfaceDeclared.session", ejbClass.getSimpleName());
#1.noInterfaceDeclared.session = Business Interface or @WebService annotation required.
#2.noInterfaceDeclared.session = Business Interface or @WebService annotation required.
#3.noInterfaceDeclared.session = All EJB 3.0 and earlier Session beans must either implement an interface, declare one via annotation or xml, or be annotated with @javax.jws.WebService.  An example interface for this bean might be:\
#    @Local\
#    public interface {0}Local '\u007B' \
#        // add the methods from {0} you'd like to expose  \
#    '\u007D' \
#\
#Which can then be implemented by the {0} class.\


# fail(ejbName, "ann.notAnInterface", annotationName, interfce.getName());
1.ann.notAnInterface = @{0} lists a non-interface.
2.ann.notAnInterface = @{0} lists a non-interface: {1}
3.ann.notAnInterface = All business remote and business local views must be java interfaces.  Classes, abstract classes or enums are not allowed.  Either convert {1} to an interface or remove it from the @{0} list in the bean class.

# warn(b, "interface.beanOnlyAnnotation", annotation.getSimpleName(), interfce.getName(), b.getEjbClass());
1.interface.beanOnlyAnnotation = Ignoring @{0}.  Annotation only usable on the bean class.
2.interface.beanOnlyAnnotation = Ignoring @{0} used on interface {1}.  Annotation only usable on the bean class.
3.interface.beanOnlyAnnotation = @{0} is only usable on the bean classes, not its interfaces.  This annotation will be ignored unless it is moved to the bean class {2}.

# warn(b, "interfaceMethod.beanOnlyAnnotation", annotation.getSimpleName(), interfce.getName(), method.getName(), b.getEjbClass());
1.interfaceMethod.beanOnlyAnnotation = Ignoring @{0}.  Annotation only usable on the bean class.
2.interfaceMethod.beanOnlyAnnotation = Ignoring @{0} used on interface {1} method {2}.  Annotation only usable on the bean class.
3.interfaceMethod.beanOnlyAnnotation = @{0} is only usable on the bean classes, not its interfaces.  This annotation will be ignored unless it is moved to the {2} method in the bean class {3}.

# fail(ejbName, "permitAllAndRolesAllowedOnClass", clazz.getName());
1.permitAllAndRolesAllowedOnClass = @RolesAllowed and @PermitAll cannot be used on the same class
2.permitAllAndRolesAllowedOnClass = @RolesAllowed and @PermitAll cannot be used on the same class: {0}
3.permitAllAndRolesAllowedOnClass = The @RolesAllowed and @PermitAll annotations are mutually exclussive and cannot be used together on the same class.  Choose between @RolesAllowed, which will restrict access to the listed authenticated roles, and @PermitAll, which will allow access to anyone authenticated or not, then update class {0} by deleting the annotation you do not wish to use.  Alternatively, @RolesAllowed can be used at the class level and @PermitAll can be used on individual methods and vice versa.

# fail(ejbName, "conflictingSecurityAnnotations", method.getName(), join(" and ", annotations), method.getDeclaringClass());
1.conflictingSecurityAnnotations = Method has conflicting security annotations.
2.conflictingSecurityAnnotations = Method has conflicting security annotations: "{0}" uses {1}
3.conflictingSecurityAnnotations = The {1} annotations are mutually exclussive and cannot be used together on the same method.  Choose the security annotation you want and delete the others from method {0} in class {2}.  @RolesAllowed will restrict access to the listed authenticated roles.  @PermitAll will allow access to anyone authenticated or not.  @DenyAll will deny access to anyone authenticated or not.

# warn(ejbName, "xml.invalidTransactionAttribute", count);
1.xml.invalidTransactionAttribute = Ignoring invalid <container-transaction> declarations.  Bean not using Container-Managed Transactions.
2.xml.invalidTransactionAttribute = Ignoring {0} invalid <container-transaction> declarations.  Bean not using Container-Managed Transactions.
3.xml.invalidTransactionAttribute = The <container-transaction> element applies only to beans using Container-Managed Transactions.  Beans marked as <transaction-type>Bean</transaction-type> are responsible for their own transactions and may not use the <container-transaction> element.  There are {0} such invalid declarations in the deployment descriptor that will be ignored and should be removed.

# warn(ejbName, "ann.invalidTransactionAttribute", count);
1.ann.invalidTransactionAttribute = Ignoring invalid @TransactionAttribute annotations.  Bean not using Container-Managed Transactions.
2.ann.invalidTransactionAttribute = Ignoring {0} invalid @TransactionAttribute annotations.  Bean not using Container-Managed Transactions.
3.ann.invalidTransactionAttribute = The @TransactionAttribute annotation applies only to beans using Container-Managed Transactions.  Beans marked as @TransactionManagement(BEAN) are responsible for their own transactions and may not use the @TransactionAttribute annotation.  There are {0} such invalid annotations in the bean class that will be ignored and should be removed.
#TODO
# warn(ejbName, "xml.invalidConcurrencyAttribute", count);
#1.xml.invalidConcurrencyAttribute = Ignoring invalid <container-concurrency> declarations.  Bean not using Container-Managed Concurrency.
#2.xml.invalidConcurrencyAttribute = Ignoring {0} invalid <container-concurrency> declarations.  Bean not using Container-Managed Concurrency.
#3.xml.invalidConcurrencyAttribute = The <container-concurrency> element applies only to beans using Container-Managed Concurrency.  Beans marked as <concurrency-type>Bean</concurrency-type> are responsible for thier own concurrency and may not use the <container-concurrency> element.  There are {0} such invalid declarations in the deployment descriptor that will be ignored and should be removed.

# warn(ejbName, "ann.invalidConcurrencyAttribute", count);
1.ann.invalidConcurrencyAttribute = Ignoring invalid @Lock annotations.  Bean not using Container-Managed Concurrencys.
2.ann.invalidConcurrencyAttribute = Ignoring {0} invalid @Lock annotations.  Bean not using Container-Managed Concurrencys.
3.ann.invalidConcurrencyAttribute = The @Lock annotation applies only to beans using Container-Managed Concurrencys.  Beans marked as @ConcurrencyManagement(BEAN) are responsible for thier own concurrency and may not use the @Lock annotation.  There are {0} such invalid annotations in the bean class that will be ignored and should be removed.


1.xml.home.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <home>. Use <local-home>{0}</local-home>
2.xml.home.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <home>. Use <local-home>{0}</local-home>
3.xml.home.ejbLocalHome = The <home> element is for interfaces extending javax.ejb.EJBHome.  The interface supplied is a javax.ejb.EJBLocalHome and should be declared with the <local-home> element as in: <local-home>{0}</local-home>

1.xml.home.ejbObject = javax.ejb.EJBObject interface declared as <home>. Use <remote>{0}</remote>
2.xml.home.ejbObject = javax.ejb.EJBObject interface declared as <home>. Use <remote>{0}</remote>
3.xml.home.ejbObject = The <home> element is for interfaces extending javax.ejb.EJBHome.  The interface supplied is a javax.ejb.EJBObject and should be declared with the <remote> element as in: <remote>{0}</remote>

1.xml.home.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <home>. Use <local>{0}</local>
2.xml.home.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <home>. Use <local>{0}</local>
3.xml.home.ejbLocalObject = The <home> element is for interfaces extending javax.ejb.EJBHome.  The interface supplied is a javax.ejb.EJBLocalObject and should be declared with the <local> element as in: <local>{0}</local>

1.xml.home.businessLocal = EJB 3.0 business interface declared as <home>. Use <business-local>{0}</business-local>
2.xml.home.businessLocal = EJB 3.0 business interface declared as <home>. Use <business-local>{0}</business-local>
3.xml.home.businessLocal = The <home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBHome.  EJB 3.0 simplified business interfaces can be decalred via <business-local>{0}</business-local> or via the @Remote annotation on the bean class or interface class.

1.xml.home.businessRemote = EJB 3.0 business interface declared as <home>. Use <business-remote>{0}</business-remote>
2.xml.home.businessRemote = EJB 3.0 business interface declared as <home>. Use <business-remote>{0}</business-remote>
3.xml.home.businessRemote = The <home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBHome.  EJB 3.0 simplified business interfaces can be decalred via <business-remote>{0}</business-remote> or via the @Remote annotation on the bean class or interface class.

1.xml.home.beanClass = Bean class mistakenly declared as <home>
2.xml.home.beanClass = Bean class mistakenly declared as <home>
3.xml.home.beanClass = The <home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBHome.  The bean class cannot be used as a home interface.

1.xml.home.notInterface = The value of <home> is not an interface
2.xml.home.notInterface = The value of <home> is not an interface: {0}
3.xml.home.notInterface = The <home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBHome.  Classes, abstract classes or enums are not allowed.  Either convert {0} to an interface or remove the related <home> xml tag from your ejb-jar.xml

1.xml.home.unknown = The value of <home> must be an interface extending javax.ejb.EJBHome
2.xml.home.unknown = The value of <home> must be an interface extending javax.ejb.EJBHome
3.xml.home.unknown = The <home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBHome.  If this interface is intended to be an EJB 3.0 business remote view, declare this interface as <business-remote>{0}</business-remote> or via the @Remote annotation on the bean class or interface class.



1.xml.remote.ejbHome = javax.ejb.EJBHome interface declared as <remote>. Use <home>{0}</home>
2.xml.remote.ejbHome = javax.ejb.EJBHome interface declared as <remote>. Use <home>{0}</home>
3.xml.remote.ejbHome = The <remote> element is for interfaces extending javax.ejb.EJBObject.  The interface supplied is a javax.ejb.EJBHome and should be declared with the <home> element as in: <home>{0}</home>

1.xml.remote.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <remote>. Use <local-home>{0}</local-home>
2.xml.remote.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <remote>. Use <local-home>{0}</local-home>
3.xml.remote.ejbLocalHome = The <remote> element is for interfaces extending javax.ejb.EJBHome.  The interface supplied is a javax.ejb.EJBLocalHome and should be declared with the <local-home> element as in: <local-home>{0}</local-home>

1.xml.remote.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <remote>. Use <local>{0}</local>
2.xml.remote.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <remote>. Use <local>{0}</local>
3.xml.remote.ejbLocalObject = The <remote> element is for interfaces extending javax.ejb.EJBObject.  The interface supplied is a javax.ejb.EJBLocalObject and should be declared with the <local> element as in: <local>{0}</local>

# must be attempting an override
1.xml.remote.businessLocal = EJB 3.0 business interface declared as <remote>. Use <business-remote>{0}</business-remote>
2.xml.remote.businessLocal = EJB 3.0 business interface declared as <remote>. Use <business-remote>{0}</business-remote>
3.xml.remote.businessLocal = The <remote> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBObject.  EJB 3.0 simplified business interfaces can be decalred via <business-local>{0}</business-local> or via the @Remote annotation on the bean class or interface class.

1.xml.remote.businessRemote = EJB 3.0 business interface declared as <remote>. Use <business-remote>{0}</business-remote>
2.xml.remote.businessRemote = EJB 3.0 business interface declared as <remote>. Use <business-remote>{0}</business-remote>
3.xml.remote.businessRemote = The <remote> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBObject.  EJB 3.0 simplified business interfaces can be decalred via <business-remote>{0}</business-remote> or via the @Remote annotation on the bean class or interface class.

1.xml.remote.beanClass = Bean class mistakenly declared as <remote>
2.xml.remote.beanClass = Bean class mistakenly declared as <remote>
3.xml.remote.beanClass = The <remote> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBObject.  The bean class cannot be used as a home interface.

1.xml.remote.notInterface = The value of <remote> is not an interface
2.xml.remote.notInterface = The value of <remote> is not an interface: {0}
3.xml.remote.notInterface = The <remote> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBObject.  Classes, abstract classes or enums are not allowed.  Either convert {0} to an interface or remove the related <remote> xml tag from your ejb-jar.xml

1.xml.remote.unknown = The value of <remote> must be an interface extending javax.ejb.EJBObject
2.xml.remote.unknown = The value of <remote> must be an interface extending javax.ejb.EJBObject.  Perhaps you meant to use <business-remote>{0}</business-remote>
3.xml.remote.unknown = The <remote> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBObject.  If this interface is intended to be an EJB 3.0 business remote view, declare this interface as <business-remote>{0}</business-remote> or via the @Remote annotation on the bean class or interface class.




1.xml.localHome.ejbHome = javax.ejb.EJBHome interface declared as <local-home>. Use <home>{0}</home>
2.xml.localHome.ejbHome = javax.ejb.EJBHome interface declared as <local-home>. Use <home>{0}</home>
3.xml.localHome.ejbHome = The <local-home> element is for interfaces extending javax.ejb.EJBLocalHome.  The interface supplied is a javax.ejb.EJBHome and should be declared with the <home> element as in: <home>{0}</home>

1.xml.localHome.ejbObject = javax.ejb.EJBObject interface declared as <local-home>. Use <remote>{0}</remote>
2.xml.localHome.ejbObject = javax.ejb.EJBObject interface declared as <local-home>. Use <remote>{0}</remote>
3.xml.localHome.ejbObject = The <local-home> element is for interfaces extending javax.ejb.EJBLocalHome.  The interface supplied is a javax.ejb.EJBObject and should be declared with the <remote> element as in: <remote>{0}</remote>

1.xml.localHome.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <local-home>. Use <local>{0}</local>
2.xml.localHome.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <local-home>. Use <local>{0}</local>
3.xml.localHome.ejbLocalObject = The <local-home> element is for interfaces extending javax.ejb.EJBLocalHome.  The interface supplied is a javax.ejb.EJBLocalObject and should be declared with the <local> element as in: <local>{0}</local>

1.xml.localHome.businessLocal = EJB 3.0 business interface declared as <local-home>. Use <business-local>{0}</business-local>
2.xml.localHome.businessLocal = EJB 3.0 business interface declared as <local-home>. Use <business-local>{0}</business-local>
3.xml.localHome.businessLocal = The <local-home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalHome.  EJB 3.0 simplified business interfaces can be decalred via <business-local>{0}</business-local> or via the @Remote annotation on the bean class or interface class.

1.xml.localHome.businessRemote = EJB 3.0 business interface declared as <local-home>. Use <business-remote>{0}</business-remote>
2.xml.localHome.businessRemote = EJB 3.0 business interface declared as <local-home>. Use <business-remote>{0}</business-remote>
3.xml.localHome.businessRemote = The <local-home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalHome.  EJB 3.0 simplified business interfaces can be decalred via <business-remote>{0}</business-remote> or via the @Remote annotation on the bean class or interface class.

1.xml.localHome.beanClass = Bean class mistakenly declared as <local-home>
2.xml.localHome.beanClass = Bean class mistakenly declared as <local-home>
3.xml.localHome.beanClass = The <local-home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalHome.  The bean class cannot be used as a home interface.

1.xml.localHome.notInterface = The value of <local-home> is not an interface
2.xml.localHome.notInterface = The value of <local-home> is not an interface: {0}
3.xml.localHome.notInterface = The <local-home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalHome.  Classes, abstract classes or enums are not allowed.  Either convert {0} to an interface or remove the related <local-home> xml tag from your ejb-jar.xml

1.xml.localHome.unknown = The value of <local-home> must be an interface extending javax.ejb.EJBLocalHome
2.xml.localHome.unknown = The value of <local-home> must be an interface extending javax.ejb.EJBLocalHome
3.xml.localHome.unknown =  The <local-home> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalHome.  If this interface is intended to be an EJB 3.0 business local view, declare this interface as <business-local>{0}</business-local> or via the @Local annotation on the bean class or interface class.




1.xml.local.ejbHome = javax.ejb.EJBHome interface declared as <local>. Use <home>{0}</home>
2.xml.local.ejbHome = javax.ejb.EJBHome interface declared as <local>. Use <home>{0}</home>
3.xml.local.ejbHome = The <local> element is for interfaces extending javax.ejb.EJBLocalObject.  The interface supplied is a javax.ejb.EJBHome and should be declared with the <home> element as in: <home>{0}</home>

1.xml.local.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <local>. Use <local-home>{0}</local-home>
2.xml.local.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <local>. Use <local-home>{0}</local-home>
3.xml.local.ejbLocalHome = The <local> element is for interfaces extending javax.ejb.EJBLocalObject.  The interface supplied is a javax.ejb.EJBLocalHome and should be declared with the <local-home> element as in: <local-home>{0}</local-home>

1.xml.local.ejbObject = javax.ejb.EJBObject interface declared as <local>. Use <remote>{0}</remote>
2.xml.local.ejbObject = javax.ejb.EJBObject interface declared as <local>. Use <remote>{0}</remote>
3.xml.local.ejbObject = The <local> element is for interfaces extending javax.ejb.EJBLocalObject.  The interface supplied is a javax.ejb.EJBObject and should be declared with the <remote> element as in: <remote>{0}</remote>

1.xml.local.businessLocal = EJB 3.0 business interface declared as <local>. Use <business-local>{0}</business-local>
2.xml.local.businessLocal = EJB 3.0 business interface declared as <local>. Use <business-local>{0}</business-local>
3.xml.local.businessLocal = The <local> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalObject.  EJB 3.0 simplified business interfaces can be decalred via <business-local>{0}</business-local> or via the @Remote annotation on the bean class or interface class.

# must be attempting an override
1.xml.local.businessRemote = EJB 3.0 business interface declared as <local>. Use <business-local>{0}</business-local>
2.xml.local.businessRemote = EJB 3.0 business interface declared as <local>. Use <business-local>{0}</business-local>
3.xml.local.businessRemote = The <local> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalObject.  EJB 3.0 simplified business interfaces can be decalred via <business-remote>{0}</business-remote> or via the @Remote annotation on the bean class or interface class.

1.xml.local.beanClass = Bean class mistakenly declared as <local>
2.xml.local.beanClass = Bean class mistakenly declared as <local>
3.xml.local.beanClass = The <local> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalObject.  The bean class cannot be used as a home interface.

1.xml.local.notInterface = The value of <local> is not an interface
2.xml.local.notInterface = The value of <local> is not an interface: {0}
3.xml.local.notInterface = The <local> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalObject.  Classes, abstract classes or enums are not allowed.  Either convert {0} to an interface or remove the related <local> xml tag from your ejb-jar.xml

1.xml.local.unknown = The value of <local> must be an interface extending javax.ejb.EJBLocalObject
2.xml.local.unknown = The value of <local> must be an interface extending javax.ejb.EJBLocalObject.  Perhaps you meant to use <business-local>{0}</business-local>
3.xml.local.unknown = The <local> element of the ejb-jar.xml is for interfaces extending javax.ejb.EJBLocalObject.  If this interface is intended to be an EJB 3.0 business local view, declare this interface as <business-local>{0}</business-local> or via the @Local annotation on the bean class or interface class.




1.xml.businessRemote.ejbHome = javax.ejb.EJBHome interface declared as <business-remote>. Use <home>{0}</home>
2.xml.businessRemote.ejbHome = javax.ejb.EJBHome interface declared as <business-remote>. Use <home>{0}</home>
3.xml.businessRemote.ejbHome = Interfaces extending javax.ejb.EJBHome must use the <home> tag, not the <business-remote> tag, when declared in the ejb-jar.xml.  Declare this interface as <home>{0}</home> or alternatively add @RemoteHome({0}.class) to the top of your bean class.

1.xml.businessRemote.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <business-remote>. Use <local-home>{0}</local-home>
2.xml.businessRemote.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <business-remote>. Use <local-home>{0}</local-home>
3.xml.businessRemote.ejbLocalHome = Interfaces extending javax.ejb.EJBLocalHome must use the <local-home> tag, not the <business-remote> tag, when declared in the ejb-jar.xml.  Declare this interface as <local-home>{0}</local-home> or alternatively add @LocalHome({0}.class) to the top of your bean class.

1.xml.businessRemote.ejbObject = javax.ejb.EJBObject interface declared as <business-remote>. Use <remote>{0}</remote>
2.xml.businessRemote.ejbObject = javax.ejb.EJBObject interface declared as <business-remote>. Use <remote>{0}</remote>
3.xml.businessRemote.ejbObject = Interfaces extending javax.ejb.EJBObject must use the <remote> tag, not the <business-remote> tag, when declared in the ejb-jar.xml.  Declare this interface as <remote>{0}</remote>.

1.xml.businessRemote.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <business-remote>. Use <local>{0}</local>
2.xml.businessRemote.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <business-remote>. Use <local>{0}</local>
3.xml.businessRemote.ejbLocalObject = Interfaces extending javax.ejb.EJBLocalObject must use the <local> tag, not the <business-remote> tag, when declared in the ejb-jar.xml.  Declare this interface as <local>{0}</local>.

1.xml.businessRemote.beanClass = Bean class mistakenly declared as <business-remote>
2.xml.businessRemote.beanClass = Bean class mistakenly declared as <business-remote>
3.xml.businessRemote.beanClass = The bean class cannot itself be used as the value of the <business-remote> element of the ejb-jar.xml.  Either list a valid java interface or delete this element and annotate the intended interface with the @Remote annotation.

1.xml.businessRemote.notInterface = The value of <business-remote> is not an interface
2.xml.businessRemote.notInterface = The value of <business-remote> is not an interface: {0}
3.xml.businessRemote.notInterface = The <business-remote> element of the ejb-jar.xml must be an interface.  Classes, abstract classes or enums are not allowed.  Either convert {0} to an interface or remove the related <business-remote> xml tag from your ejb-jar.xml

1.xml.businessLocal.ejbHome = javax.ejb.EJBHome interface declared as <business-local>. Use <home>{0}</home>
2.xml.businessLocal.ejbHome = javax.ejb.EJBHome interface declared as <business-local>. Use <home>{0}</home>
3.xml.businessLocal.ejbHome = Interfaces extending javax.ejb.EJBHome must use the <home> tag, not the <business-local> tag, when declared in the ejb-jar.xml.  Declare this interface as <home>{0}</home> or alternatively add @RemoteHome({0}.class) to the top of your bean class.

1.xml.businessLocal.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <business-local>. Use <local-home>{0}</local-home>
2.xml.businessLocal.ejbLocalHome = javax.ejb.EJBLocalHome interface declared as <business-local>. Use <local-home>{0}</local-home>
3.xml.businessLocal.ejbLocalHome = Interfaces extending javax.ejb.EJBLocalHome must use the <local-home> tag, not the <business-local> tag, when declared in the ejb-jar.xml.  Declare this interface as <local-home>{0}</local-home> or alternatively add @LocalHome({0}.class) to the top of your bean class.

1.xml.businessLocal.ejbObject = javax.ejb.EJBObject interface declared as <business-local>. Use <remote>{0}</remote>
2.xml.businessLocal.ejbObject = javax.ejb.EJBObject interface declared as <business-local>. Use <remote>{0}</remote>
3.xml.businessLocal.ejbObject = Interfaces extending javax.ejb.EJBObject must use the <remote> tag, not the <business-local> tag, when declared in the ejb-jar.xml.  Declare this interface as <remote>{0}</remote>.

1.xml.businessLocal.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <business-local>. Use <local>{0}</local>
2.xml.businessLocal.ejbLocalObject = javax.ejb.EJBLocalObject interface declared as <business-local>. Use <local>{0}</local>
3.xml.businessLocal.ejbLocalObject = Interfaces extending javax.ejb.EJBLocalObject must use the <local> tag, not the <business-local> tag, when declared in the ejb-jar.xml.  Declare this interface as <local>{0}</local>.

1.xml.businessLocal.beanClass = Bean class mistakenly declared as <business-local>
2.xml.businessLocal.beanClass = Bean class mistakenly declared as <business-local>
3.xml.businessLocal.beanClass = The bean class cannot itself be used as the value of the <business-local> element of the ejb-jar.xml.  Either 1) list a valid java interface or 2) delete this element and annotate the intended interface with the @Local annotation.

1.xml.businessLocal.notInterface = The value of <business-local> is not an interface
2.xml.businessLocal.notInterface = The value of <business-local> is not an interface: {0}
3.xml.businessLocal.notInterface = The <business-local> element of the ejb-jar.xml must be an interface.  Classes, abstract classes or enums are not allowed.  Either convert {0} to an interface or remove the related <business-local> xml tag from your ejb-jar.xml


# TODO: add the apostrophes back in "beans"
1.ann.ejb.ejbObject = @EJB mistakenly refers to a beans javax.ejb.EJBObject interface
2.ann.ejb.ejbObject = @EJB mistakenly refers to a beans javax.ejb.EJBObject interface {0}.  Use the EJBHome interface instead.
3.ann.ejb.ejbObject = When using the @EJB annotation to refer to older EJB 2.x component interfaces, it is the the home interface should be referenced/injected via @EJB.  The home interface is then used in code to create a reference to the {0} interface.  Change the reference type of {1} to the beans home interface.

1.ann.ejb.ejbLocalObject = @EJB mistakenly refers to a beans javax.ejb.EJBLocalObject interface
2.ann.ejb.ejbLocalObject = @EJB mistakenly refers to a beans javax.ejb.EJBLocalObject interface {0}.  Use the EJBLocalHome interface instead.
3.ann.ejb.ejbLocalObject = When using the @EJB annotation to refer to older EJB 2.x component interfaces, it is the the local home interface should be referenced/injected via @EJB.  The local home interface is then used in code to create a reference to the {0} interface.  Change the reference type of {1} to the beans local home interface.

1.ann.ejb.beanClass = @EJB mistakenly refers to a bean class
2.ann.ejb.beanClass = @EJB mistakenly refers to a bean class {0}.  Use the beans business interface instead
3.ann.ejb.beanClass = The @EJB annotation cannot be used to directly refer to the bean class itself and must instead refer to the bean using one of its business interfaces.  Change the type of the {1} reference from {0} to a business interface of that bean.

1.ann.ejb.notInterface = @EJB mistakenly refers to a non-interface
2.ann.ejb.notInterface = @EJB mistakenly refers to a non-interface.  Use the beans business interface instead
3.ann.ejb.notInterface = The @EJB annotation cannot be used to directly refer to the bean class itself and must instead refer to the bean using one of its business interfaces.  Change the type of the {1} reference from {0} to a business interface of that bean.

# fail(enterpriseBean.getEjbName(), "dependsOn.noSuchEjb", ejbName);
1.dependsOn.noSuchEjb = Singleton @DependsOn refers to non-existant EJB:
2.dependsOn.noSuchEjb = Singleton @DependsOn refers to non-existant EJB: {0}
3.dependsOn.noSuchEjb = The @DependsOn annotation or <depends-on> descriptor data for this Singeton bean lists an EJB "{0}" which does not exist in any of the modules of the ear.

# fail("EAR", "dependsOn.circuit", Join.join(" -> ", ejbNames), ejbNames.get(0));
1.dependsOn.circuit = Singleton circular dependency detected
2.dependsOn.circuit = Singleton circular dependency detected: {0}
3.dependsOn.circuit = A Singleton circular dependency has been detected in the application.  Bean "{1}" refers to one or more other singleton beans via @DependsOn which directly or indirectly refer back to bean "{1}".  This circle must be broken befor the application can be built: {0}

# CheckUserTransactionRefs.java
# warn(bean, "userResourceRef.forbiddenForCmtdBeans", resRef.getResourceEnvRefName());
1.userTransactionRef.forbiddenForCmtdBeans = Container-Managed Transaction beans cannot use UserTransaction
2.userTransactionRef.forbiddenForCmtdBeans = Container-Managed Transaction beans cannot use UserTransaction: fix ref {0}
3.userTransactionRef.forbiddenForCmtdBeans = Only session and message-driven beans with bean-managed transaction demarcation are allowed to use UserTransaction.  Fix @Resource or resource-env-ref {0}

1.xml.noEjbClass = Element <ejb-class> unspecified.
2.xml.noEjbClass = Element <ejb-class> unspecified.  No annotated bean discovered with <ejb-name>{0}</ejb-name>
3.xml.noEjbClass = The <ejb-class> element is only optional if there is a matching annotated bean in the module with the bean name {0}.  No such bean was found.  Other beans in this module are: {1}  
